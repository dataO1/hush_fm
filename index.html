<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Silent Disco (SFU)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Place livekit-client.min.js into ./static/ (no external URLs) -->
  <script src="/static/livekit-client.min.js"></script>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; }
    .row { display:flex; gap:16px; flex-wrap:wrap; }
    .card { border:1px solid #ddd; border-radius:8px; padding:12px; min-width:280px; }
    #log { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 12px; background:#fafafa; border:1px solid #eee; padding:8px; max-height:260px; overflow:auto; }
    button { cursor: pointer; }
  </style>
</head>
<body>
  <h2>Silent Disco (SFU)</h2>

  <div class="row">
    <div class="card">
      <h3>Identity</h3>
      <div>Client: <span id="clientId">-</span></div>
      <div>Name: <span id="clientName">-</span></div>
      <button id="btnIdentify">Identify</button>
    </div>

    <div class="card">
      <h3>Create Room (DJ)</h3>
      <input id="roomName" placeholder="Room name" value="My Disco" />
      <button id="btnCreate">Create as DJ</button>
      <div>Room: <span id="roomId">-</span></div>
      <div>Role: <span id="role">-</span></div>
      <button id="btnPlayLocal" disabled>Play DJ Local</button>
    </div>

    <div class="card">
      <h3>Join Room (Listener)</h3>
      <input id="joinRoomId" placeholder="Room ID" />
      <button id="btnJoin">Join as Listener</button>
      <div>Role: <span id="role2">-</span></div>
      <audio id="listenerAudio" controls autoplay playsinline></audio>
    </div>
  </div>

  <h3>Log</h3>
  <div id="log"></div>

<script>
const t0 = performance.now();
const ts = () => (performance.now() - t0).toFixed(1);
const logEl = document.getElementById('log');
const log = (...a) => { console.log(...a); logEl.textContent += `[${ts()}ms] ` + a.map(x => typeof x === 'string' ? x : JSON.stringify(x)).join(' ') + '\n'; };

let ws = null; // retained for UX parity; LiveKit handles signaling internally
let ICE_CONFIG = { iceServers: [] }; // unused in SFU path; kept for compatibility

const state = {
  clientId: null,
  name: null,
  role: null,      // 'dj' or 'listener'
  roomId: null,
  lkRoom: null,    // LiveKit Room
  localTrack: null // DJ local audio track
};

async function loadIceConfig() {
  const res = await fetch('/config');
  const data = await res.json();
  ICE_CONFIG = { iceServers: data.iceServers || [] };
  log('Loaded ICE servers', ICE_CONFIG.iceServers?.length || 0);
}

async function identify() {
  const res = await fetch('/user/identify', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({}) });
  const data = await res.json();
  state.clientId = data.client_id;
  state.name = data.name;
  document.getElementById('clientId').textContent = state.clientId;
  document.getElementById('clientName').textContent = state.name;
  log('User identified', state.name, state.clientId);
}

async function connectWS() {
  // Optional: if you still want presence/events; not required for LiveKit media
  ws = { readyState: 1, send: () => {} };
  log('WebSocket placeholder ready');
}

// LiveKit helpers
async function fetchLkToken(role, roomId) {
  const res = await fetch('/lk/token', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ client_id: state.clientId, role, room_id: roomId }) });
  const data = await res.json();
  if (!data.ok) throw new Error(data.error || 'lk token failed');
  return data;
}

async function createLkRoomAndConnect(url, token) {
  const { Room, RoomEvent, setLogLevel, LogLevel, AudioPresets } = LivekitClient;
  setLogLevel(LogLevel.warn);
  const room = new Room({
    // Keep latency low; SFU will forward without mixing/transcoding
    adaptiveStream: false,
    dynacast: false
  });
  room.on(RoomEvent.Connected, () => log('LiveKit connected'));
  room.on(RoomEvent.Disconnected, () => log('LiveKit disconnected'));
  room.on(RoomEvent.ConnectionQualityChanged, (_, q) => log('conn quality', q));
  room.on(RoomEvent.ParticipantConnected, (p) => log('participant joined', p.identity));
  room.on(RoomEvent.ParticipantDisconnected, (p) => log('participant left', p.identity));

  // Subscribe to audio
  room.on(RoomEvent.TrackSubscribed, (track, pub, participant) => {
    if (track.kind === 'audio') {
      const el = document.getElementById('listenerAudio');
      track.attach(el);
      el.setAttribute('preload', 'auto');
      el.play().then(() => log('listener audio playing')).catch(e => log('play error', e?.message || e));
      log('subscribed audio from', participant.identity);
    }
  });
  room.on(RoomEvent.TrackUnsubscribed, (track) => { try { track.detach(); } catch {} });

  await room.connect(url, token);
  state.lkRoom = room;
  return room;
}

async function ensureDjAudioTrack() {
  if (state.localTrack) return state.localTrack;
  const { LocalAudioTrack, createLocalAudioTrack, TrackPublishOptions,
    AudioCaptureOptions } = LivekitClient;
  // Music-friendly capture: stereo, 48k, disable AGC/NS/EC to avoid coloration
  const constraints = {
    audio: {
      channelCount: 2,
      sampleRate: 48000,
      echoCancellation: false,
      noiseSuppression: false,
      autoGainControl: false
    }
  };
  const stream = await navigator.mediaDevices.getUserMedia(constraints);
  const track = await createLocalAudioTrack({
    deviceId: stream.getAudioTracks()[0].getSettings().deviceId,
    // LiveKit will pick Opus; keep it low-latency
  });
  // Replace the underlying MediaStreamTrack with our captured one
  await track.restart({ noiseSuppression: false, echoCancellation: false, autoGainControl: false, channelCount: 2, sampleRate: 48000 });
  state.localTrack = track;
  log('DJ audio track ready (stereo 48k)');
  return track;
}

async function publishDjAudio(room) {
  // Publish with options tuned for music: disable DTX, enable RED if supported
  const opts = {
    dtx: false,   // keep continuous frames for music
    red: true,    // redundancy improves loss resilience if supported
    // bitrate left to auto; SFU + Opus will negotiate
  };
  const track = await ensureDjAudioTrack();
  await room.localParticipant.publishTrack(track, opts);
  log('Published DJ audio');
}

// UI handlers
document.getElementById('btnIdentify').onclick = async () => { await identify(); await loadIceConfig(); await connectWS(); };

document.getElementById('btnCreate').onclick = async () => {
  if (!state.clientId) { await identify(); await loadIceConfig(); await connectWS(); }
  const name = (document.getElementById('roomName').value || 'My Disco').trim();
  const res = await fetch('/room/create', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ client_id: state.clientId, name }) });
  const data = await res.json();
  if (!data.ok) { log('create failed', data.error || ''); return; }
  state.roomId = data.room_id;
  state.role = 'dj';
  document.getElementById('roomId').textContent = state.roomId;
  document.getElementById('role').textContent = 'dj';

  const { url, token } = await fetchLkToken('dj', state.roomId);
  const room = await createLkRoomAndConnect(url, token);
  await publishDjAudio(room);
  document.getElementById('btnPlayLocal').disabled = false;
  log('DJ ready; published to SFU');
};

document.getElementById('btnPlayLocal').onclick = async () => {
  // Local monitor for DJ
  await ensureDjAudioTrack();
  const el = new Audio();
  el.srcObject = new MediaStream([state.localTrack.mediaStreamTrack]);
  el.autoplay = true;
  el.playsInline = true;
  el.muted = false;
  el.play().then(() => log('Playing (local)')).catch(e => log('Local play error', e?.message || e));
};

document.getElementById('btnJoin').onclick = async () => {
  if (!state.clientId) { await identify(); await loadIceConfig(); await connectWS(); }
  const rid = (document.getElementById('joinRoomId').value || '').trim();
  if (!rid) { log('enter room id'); return; }
  state.roomId = rid;
  state.role = 'listener';
  document.getElementById('role2').textContent = 'listener';

  const { url, token } = await fetchLkToken('listener', state.roomId);
  await createLkRoomAndConnect(url, token);
  log('Listener ready; waiting for DJ track');
};

// Auto-identify on load
window.addEventListener('load', async () => {
  await identify();
  await loadIceConfig();
  await connectWS();
});
</script>
</body>
</html>
