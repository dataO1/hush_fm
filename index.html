<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Silent Disco</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="/static/livekit-client.min.js"></script>
  <style>
    :root {
      --bg: #0b0b12;
      --card: #12121b;
      --muted: #8b8b9a;
      --text: #f4f4f7;
      --accent: #7c5cff;
      --accent2: #1ae5c9;
      --danger: #ff5c7a;
      --radius: 14px;
      --off: #2a2a39;
      --ok: #1ae5c9;
      --wave-off: #6a6a7a;
      --wave-on: #7c5cff;
      --rec: #ff3366;
    }
    * { box-sizing: border-box; }
    html, body { margin:0; padding:0; min-height:100%; background: radial-gradient(1200px 600px at 80% -10%, #181828, transparent), var(--bg); color: var(--text); font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans"); }
    .scaffold { min-height: 100vh; display: grid; grid-template-rows: auto 1fr auto; }
    header { display:grid; place-items:center; padding: 12px 0; }
    .brand { font-weight: 800; letter-spacing: .4px; text-align:center; }
    .pill { margin-top: 6px; padding: 6px 12px; border-radius: 999px; border: 1px solid #2a2a39; background: #101018; color: var(--muted); font-size: 12px; }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 16px; width: 100%; }
    .grid { display:grid; gap: 16px; grid-template-columns: repeat(12, 1fr); }
    .card { position: relative; background: linear-gradient(180deg, #12121b 0%, #0f0f16 100%); border: 1px solid #262636; border-radius: var(--radius); padding: 16px; text-align: center; }
    .card.log { text-align: left; }
    .rooms { display:grid; gap: 12px; }
    .room-item { display:flex; justify-content: space-between; align-items:center; padding: 12px; border-radius: 12px; background: #141421; border: 1px solid #232334; text-align: left; }
    .room-meta { display:flex; gap: 12px; align-items:center; }
    .badge { font-size: 12px; padding: 6px 10px; border-radius: 999px; background: #1a1a28; color: var(--muted); border: 1px solid #26263a; }
    .btn { cursor: pointer; appearance: none; border: 0; border-radius: 12px; padding: 12px 16px; font-weight: 700; letter-spacing: .3px; transition: all 0.2s; position: relative; }
    .btn.primary { color: #0b0b12; background: linear-gradient(90deg, var(--accent) 0%, var(--accent2) 100%); }
    .btn.secondary { background: #1a1a28; color: var(--text); border: 1px solid #2b2b3d; }
    .btn.secondary.active { background: var(--accent); color: #fff; border-color: var(--accent); }
    .btn.rec { background: var(--rec); color: #fff; font-size: 24px; padding: 14px 20px; }
    .btn.rec::before { content: '●'; animation: pulse 1.5s ease-in-out infinite; }
    .btn.stopped { background: #2a2a39; color: var(--muted); border: 1px solid var(--off); font-size: 20px; padding: 14px 20px; }
    .btn.stopped::before { content: '■'; }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.4; } }
    .btn[title]:hover::after {
      content: attr(title);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: #1a1a28;
      color: var(--text);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 12px;
      white-space: nowrap;
      margin-bottom: 8px;
      border: 1px solid #2b2b3d;
      font-weight: 400;
      z-index: 10;
    }
    .title { font-size: 22px; margin: 0 0 6px; }
    .room-title { font-size: 24px; font-weight: 800; margin: 0 0 2px; }
    .section-title { margin: 4px 0 8px; font-size: 14px; color: var(--muted); }
    .row { display:flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
    .hidden { display:none !important; }
    .accent { color: var(--accent2); }
    .field { display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content: center; }
    .input { padding: 10px 12px; border-radius: 10px; background: #11111a; color: var(--text); border: 1px solid #2b2b3d; min-width: 220px; }
    .close-float { position:absolute; top: 12px; right: 12px; }
    .dropdown { position: relative; display: inline-block; }
    .dropdown-content { display: none; position: absolute; background: #1a1a28; min-width: 200px; box-shadow: 0 8px 16px rgba(0,0,0,0.3); border-radius: 8px; z-index: 1; margin-top: 4px; border: 1px solid #2b2b3d; }
    .dropdown-content.show { display: block; }
    .dropdown-item { padding: 10px 14px; cursor: pointer; color: var(--text); border-bottom: 1px solid #2b2b3d; }
    .dropdown-item:last-child { border-bottom: none; }
    .dropdown-item:hover { background: #252535; }
    .stats-table { width: 100%; border-collapse: collapse; margin: 12px 0; font-size: 13px; }
    .stats-table td { padding: 6px 8px; border-bottom: 1px solid #232334; }
    .stats-table td:first-child { color: var(--muted); width: 40%; }
    .stats-table td:last-child { text-align: right; font-weight: 600; }
    @media (max-width: 720px) {
      .grid { grid-template-columns: repeat(6, 1fr); }
      .room-item { flex-direction: column; align-items: flex-start; gap: 8px; }
      .wrap { padding: 12px; }
      .title { font-size: 20px; }
      .room-title { font-size: 22px; }
    }
    .src-tabs { display:flex; gap: 8px; margin: 8px 0 12px; flex-wrap: wrap; justify-content: center; }
    #wave { width: 100%; height: 80px; background: #0f0f18; border-radius: 10px; border: 1px solid #232334; }
    #djWave { width: 100%; height: 60px; background: #0f0f18; border-radius: 10px; border: 1px solid #232334; }
    #offline { color: var(--muted); font-size: 13px; margin-top: 6px; }
    footer { height: 24px; }
  </style>
</head>
<body>
  <div class="scaffold">
    <header>
      <div class="brand">Silent <span class="accent">Disco</span></div>
      <div class="pill">Opus • SFU • Low latency</div>
    </header>

    <main class="wrap">
      <!-- Landing -->
      <section id="landing" class="grid hidden">
        <div class="card" style="grid-column: 1 / -1;">
          <div class="row" style="align-items:center;">
            <div>
              <div class="title">Pick a room or start as DJ</div>
              <div class="section-title">No codes — just tap and play</div>
            </div>
          </div>
          <div class="row">
            <div class="field">
              <input id="roomNameInput" class="input" placeholder="Room name (e.g., Neon Groove)" />
              <button id="btnCreate" class="btn primary" title="Create DJ room">Create room (DJ)</button>
            </div>
          </div>
        </div>

        <div id="roomsCard" class="card" style="grid-column: 1 / -1;">
          <div class="title">Live rooms</div>
          <div class="rooms" id="roomsList"></div>
        </div>
      </section>

      <!-- DJ View -->
      <section id="djView" class="grid hidden">
        <div class="card" style="grid-column: 1 / -1;">
          <button id="btnClose" class="btn secondary close-float" title="Close room">Close floor</button>
          <div class="room-title" id="djRoomTitle">Room</div>
          <div class="section-title">ID <span id="djRoomId"></span> • You: <span id="djName"></span></div>
        </div>

        <div class="card" style="grid-column: 1 / -1;">
          <div class="row" style="gap:16px; align-items:flex-start;">
            <div style="flex: 1 1 320px;">
              <div class="src-tabs">
                <button id="srcMic" class="btn secondary" title="Use microphone">Microphone</button>
                <button id="srcTrack" class="btn secondary" title="Upload audio">Upload track</button>
                <input type="file" id="fileInput" accept="audio/*" style="display:none;" />
                <div class="dropdown">
                  <button id="srcExternal" class="btn secondary" title="External audio">External device ▾</button>
                  <div id="extDropdown" class="dropdown-content"></div>
                </div>
              </div>

              <div class="row">
                <button id="btnMute" class="btn stopped" title="Toggle broadcast"></button>
              </div>
            </div>

            <div style="flex: 1 1 280px;">
              <canvas id="djWave" height="60"></canvas>
            </div>
          </div>
        </div>
      </section>

      <!-- Listener View -->
      <section id="listenerView" class="grid hidden">
        <div class="card" style="grid-column: 1 / -1;">
          <div class="room-title" id="lsRoomTitle">Room</div>
          <div class="section-title">ID <span id="lsRoomId"></span> • DJ <span id="lsDj"></span> • Listeners <span id="lsCount"></span></div>
          <div id="offline" class="hidden">DJ offline, waiting for stream…</div>
        </div>
        <div class="card" style="grid-column: 1 / -1;">
          <canvas id="wave" height="80"></canvas>
          <audio id="listenerAudio" autoplay playsinline></audio>
        </div>
      </section>

      <!-- Connection Stats -->
      <section id="statsCard" class="grid hidden">
        <div class="card" style="grid-column: 1 / -1;">
          <div class="title">Connection Health</div>
          <table class="stats-table">
            <tr><td>State</td><td id="statState">—</td></tr>
            <tr><td>Latency (RTT)</td><td id="statLatency">—</td></tr>
            <tr><td>Bitrate</td><td id="statBitrate">—</td></tr>
            <tr><td>Packet Loss</td><td id="statLoss">—</td></tr>
            <tr><td>Codec</td><td id="statCodec">—</td></tr>
          </table>
        </div>
      </section>

      <!-- Debug Log -->
      <section id="logCard" class="grid">
        <div class="card log" style="grid-column: 1 / -1;">
          <div class="title">Log</div>
          <pre id="log" style="white-space:pre-wrap; font-size:12px; color:#b9b9c9; margin:0;"></pre>
        </div>
      </section>
    </main>

    <footer></footer>
  </div>

<script>
const t0 = performance.now();
const ts = () => (performance.now()-t0).toFixed(1);
const logEl = document.getElementById('log');
const log = (...a)=>{ console.log(...a); logEl.textContent += `[${ts()}ms] `+a.map(x=> typeof x==='string'?x:JSON.stringify(x)).join(' ') + '\n'; };

const LK = (typeof LivekitClient !== 'undefined') ? LivekitClient : window.LivekitClient;

let ICE_CONFIG = { iceServers: [] };
const state = {
  clientId: null, name: null, role: null, roomId: null, roomName: '',
  lkRoom: null,
  localTrack: null,
  currentPub: null,
  onAir: false,
  source: 'mic',
  file: null,
  fileAudioEl: null,
  audioCtx: null, waveSrc: null,
  analyser: null, raf: 0,
  djAnalyser: null, djRaf: 0,
  extDeviceId: null,
  listenerAttached: false,
  statsInterval: null
};

const landing = document.getElementById('landing');
const djView = document.getElementById('djView');
const listenerView = document.getElementById('listenerView');
const statsCard = document.getElementById('statsCard');
const roomsList = document.getElementById('roomsList');
const offline = document.getElementById('offline');
const btnMute = document.getElementById('btnMute');

function show(section) {
  landing.classList.add('hidden');
  djView.classList.add('hidden');
  listenerView.classList.add('hidden');
  section.classList.remove('hidden');
  if (section === djView || section === listenerView) statsCard.classList.remove('hidden');
  else statsCard.classList.add('hidden');
}

function parseRoute() {
  const path = location.pathname.replace(/\/+$/, '');
  const m = path.match(/^\/r\/([a-f0-9]{8})$/i);
  const params = new URLSearchParams(location.search);
  return { roomId: m ? m[1] : null, asDj: params.get('dj') === '1' };
}

function navigateToRoom(roomId, asDj=false) { history.pushState({}, '', `/r/${roomId}${asDj ? '?dj=1' : ''}`); }
function navigateToRoot() { history.pushState({}, '', '/'); }

function updateMuteButton() {
  if (state.onAir) {
    btnMute.className = 'btn rec';
  } else {
    btnMute.className = 'btn stopped';
  }
}

function highlightActiveSource() {
  document.getElementById('srcMic').classList.toggle('active', state.source === 'mic');
  document.getElementById('srcTrack').classList.toggle('active', state.source === 'file');
  document.getElementById('srcExternal').classList.toggle('active', state.source === 'external');
}

function setDjRoomMeta() {
  document.getElementById('djRoomTitle').textContent = state.roomName || 'Room';
  document.getElementById('djRoomId').textContent = state.roomId || '';
  document.getElementById('djName').textContent = state.name || '';
}

function setListenerRoomMeta(extra) {
  document.getElementById('lsRoomTitle').textContent = extra?.name || state.roomName || 'Room';
  document.getElementById('lsRoomId').textContent = state.roomId || '';
  document.getElementById('lsDj').textContent = extra?.dj_name || '—';
  document.getElementById('lsCount').textContent = (extra?.listener_count ?? '—');
}

async function loadIceConfig() {
  const res = await fetch('/config'); const data = await res.json();
  ICE_CONFIG = { iceServers: data.iceServers || [] };
  log('Loaded ICE servers', ICE_CONFIG.iceServers?.length || 0);
}

async function identify() {
  const reuse = localStorage.getItem('sd_client_id');
  const payload = reuse ? { client_id: reuse } : {};
  const res = await fetch('/user/identify',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
  const data = await res.json();
  state.clientId = data.client_id; state.name = data.name;
  localStorage.setItem('sd_client_id', state.clientId);
  log('Identified', state.name, state.clientId);
}

async function ensureIdentityReady() { if (!state.clientId) { await identify(); await loadIceConfig(); } }

async function listRooms() {
  const res = await fetch('/rooms'); const data = await res.json();
  if (!data.ok) return;
  roomsList.innerHTML = '';
  for (const r of data.rooms) {
    const div = document.createElement('div'); div.className = 'room-item';
    const status = r.dj_online ? 'online' : 'offline';
    div.innerHTML = `
      <div class="room-meta">
        <span class="badge">#${r.id}</span>
        <div><div><strong>${r.name || 'Room'}</strong></div>
        <div class="section-title">DJ ${r.dj_name || '—'} • ${r.listener_count} listening • ${status}</div></div>
      </div>
      <div class="row">
        ${r.dj_client === state.clientId ? `<button class="btn secondary join" data-id="${r.id}" data-role="dj" title="Enter as DJ">Enter (DJ)</button>` : `<button class="btn primary join" data-id="${r.id}" data-role="listener" title="Join room">Join</button>`}
      </div>
    `;
    roomsList.appendChild(div);
  }
  roomsList.querySelectorAll('.join').forEach(btn=>{
    btn.onclick = async () => {
      const rid = btn.getAttribute('data-id'); const role = btn.getAttribute('data-role');
      navigateToRoom(rid, role === 'dj');
      await enterRoom(rid, role);
    };
  });
}

async function roomExists(roomId) {
  const res = await fetch('/rooms'); const data = await res.json();
  if (!data.ok) return false;
  return !!data.rooms.find(r => r.id === roomId);
}

async function fetchLkToken(role, roomId) {
  const res = await fetch('/lk/token',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({client_id: state.clientId, role, room_id: roomId})});
  const data = await res.json(); if (!data.ok) throw new Error(data.error || 'token failed'); return data;
}

async function connectRoom(url, token) {
  const { Room, RoomEvent, setLogLevel, LogLevel } = LK;
  setLogLevel(LogLevel.warn);
  const room = new Room({ adaptiveStream:false, dynacast:false });

  room.on(RoomEvent.Connected, async ()=>{ log('LiveKit connected'); await ensurePublishedPresence(); });
  room.on(RoomEvent.Reconnected, async ()=>{ log('LiveKit reconnected'); await ensurePublishedPresence(); });
  room.on(RoomEvent.ParticipantConnected, async ()=>{ await ensurePublishedPresence(); });
  room.on(RoomEvent.Disconnected, ()=> { log('LiveKit disconnected'); stopStatsMonitor(); });

  room.on(RoomEvent.DataReceived, (payload, participant, kind) => {
    try {
      const msg = new TextDecoder().decode(payload);
      const data = JSON.parse(msg || '{}');
      if (data?.type === 'room_close') { log('Room closing signal'); try { room.disconnect(); } catch {} navigateToRoot(); show(landing); }
    } catch {}
  });

  room.on(RoomEvent.TrackSubscribed, (track, pub, participant) => {
    if (track.kind === 'audio') {
      const el = document.getElementById('listenerAudio');
      try { el.srcObject = null; } catch {}
      track.attach(el);
      el.play().catch(()=>{});
      offline.classList.add('hidden');
      startWaveform(el);
      log('Subscribed audio from', participant.identity);
    }
  });

  room.on(RoomEvent.TrackUnsubscribed, (track) => {
    if (track.kind === 'audio') { offline.classList.remove('hidden'); stopWaveform(); }
  });

  await room.connect(url, token);
  state.lkRoom = room;
  startStatsMonitor();
  return room;
}

function isAudioPublished() {
  const room = state.lkRoom;
  if (!room || !room.localParticipant || !room.localParticipant.trackPublications) return false;
  const pubs = [...room.localParticipant.trackPublications.values()];
  return pubs.some(p => (p.track && p.track.kind === 'audio') || p.kind === 'audio');
}

async function publish(track) {
  const room = state.lkRoom;
  if (!room || !room.localParticipant) { log('Room not ready for publishing'); return; }
  try {
    if (room.localParticipant.trackPublications) {
      for (const p of [...room.localParticipant.trackPublications.values()]) {
        if (p.track?.kind === 'audio') await room.localParticipant.unpublishTrack(p.track, { stop:false });
      }
    }
  } catch (e) { log('Unpublish error (non-fatal):', e?.message || e); }
  try {
    const pub = await room.localParticipant.publishTrack(track, { dtx:true, red:true, forceStereo:true });
    state.localTrack = track;
    state.currentPub = pub;
    if (state.onAir) await pub.track.unmute(); else await pub.track.mute();
    refreshDjWave();
    log('Published single audio (stereo); onAir=', state.onAir);
  } catch (e) { log('Publish error:', e?.message || e); }
}

async function ensurePublishedPresence() {
  if (state.role !== 'dj' || !state.lkRoom || !state.lkRoom.localParticipant) return;
  if (!isAudioPublished() || !state.currentPub) {
    let track = state.localTrack;
    if (!track) {
      try {
        if (state.source === 'mic') track = await createMicTrack();
        else if (state.source === 'external') track = await createExternalTrack(state.extDeviceId);
        else if (state.source === 'file' && state.file) ({ track } = await createFileTrack(state.file));
      } catch (e) { log('Track creation error:', e?.message || e); return; }
    }
    if (track) await publish(track);
  } else {
    try {
      if (state.currentPub && state.currentPub.track) {
        if (state.onAir) await state.currentPub.track.unmute(); else await state.currentPub.track.mute();
      }
    } catch (e) { log('mute/unmute error:', e?.message || e); }
  }
}

async function createMicTrack() {
  const stream = await navigator.mediaDevices.getUserMedia({ audio: { channelCount: 2, sampleRate: 48000, echoCancellation:false, noiseSuppression:false, autoGainControl:false }, video:false });
  return stream.getAudioTracks()[0];
}

async function createExternalTrack(deviceId) {
  const constraints = { audio: { deviceId: deviceId ? { exact: deviceId } : undefined, channelCount: 2, sampleRate: 48000, echoCancellation:false, noiseSuppression:false, autoGainControl:false }, video: false };
  const stream = await navigator.mediaDevices.getUserMedia(constraints);
  return stream.getAudioTracks()[0];
}

async function createFileTrack(file) {
  const url = URL.createObjectURL(file);
  const audioEl = new Audio();
  audioEl.src = url; audioEl.crossOrigin = 'anonymous';
  audioEl.muted = true;
  await audioEl.play().catch(()=>{});
  const ctx = new (window.AudioContext||window.webkitAudioContext)();
  const src = ctx.createMediaElementSource(audioEl);
  const dst = ctx.createMediaStreamDestination();
  src.connect(dst);
  const track = dst.stream.getAudioTracks()[0];
  state.fileAudioEl = audioEl;
  state.audioCtx = ctx; state.waveSrc = src;
  return { track, audioEl };
}

function refreshDjWave() {
  stopDjWave();
  if (!state.localTrack) return;
  try {
    const ctx = new (window.AudioContext||window.webkitAudioContext)();
    const src = ctx.createMediaStreamSource(new MediaStream([state.localTrack]));
    const analyser = ctx.createAnalyser(); analyser.fftSize = 1024;
    src.connect(analyser);
    state.djAnalyser = analyser;
    const cvs = document.getElementById('djWave'); const g = cvs.getContext('2d');
    const data = new Uint8Array(analyser.frequencyBinCount);
    const draw = ()=> {
      state.djRaf = requestAnimationFrame(draw);
      analyser.getByteTimeDomainData(data);
      g.clearRect(0,0,cvs.width,cvs.height);
      g.strokeStyle = state.onAir ? getComputedStyle(document.documentElement).getPropertyValue('--wave-on').trim() : getComputedStyle(document.documentElement).getPropertyValue('--wave-off').trim();
      g.lineWidth = 2; g.beginPath();
      const step = cvs.width / data.length;
      for (let i=0;i<data.length;i++){ const v = (data[i]-128)/128; const y = cvs.height/2 + v * (cvs.height/2 - 4); const x = i * step; if (i===0) g.moveTo(x,y); else g.lineTo(x,y); }
      g.stroke();
    };
    draw();
  } catch (e) { log('dj waveform error', e?.message||e); }
}

function stopDjWave() { if (state.djRaf) cancelAnimationFrame(state.djRaf); state.djRaf = 0; state.djAnalyser = null; }

function startWaveform(audioEl) {
  try {
    stopWaveform();
    const ctx = new (window.AudioContext||window.webkitAudioContext)();
    const src = ctx.createMediaStreamSource(audioEl.srcObject);
    const analyser = ctx.createAnalyser(); analyser.fftSize = 2048;
    src.connect(analyser);
    state.analyser = analyser;
    const cvs = document.getElementById('wave'); const g = cvs.getContext('2d');
    const data = new Uint8Array(analyser.frequencyBinCount);
    const draw = ()=> {
      state.raf = requestAnimationFrame(draw);
      analyser.getByteTimeDomainData(data);
      g.clearRect(0,0,cvs.width,cvs.height);
      g.strokeStyle = '#7c5cff'; g.lineWidth = 2; g.beginPath();
      const step = cvs.width / data.length;
      for (let i=0;i<data.length;i++){ const v = (data[i]-128)/128; const y = cvs.height/2 + v * (cvs.height/2 - 4); const x = i * step; if (i===0) g.moveTo(x,y); else g.lineTo(x,y); }
      g.stroke();
    };
    draw();
  } catch (e) { log('waveform error', e?.message||e); }
}

function stopWaveform() { if (state.raf) cancelAnimationFrame(state.raf); state.raf = 0; state.analyser = null; }

function startStatsMonitor() {
  if (state.statsInterval) clearInterval(state.statsInterval);
  state.statsInterval = setInterval(async () => {
    if (!state.lkRoom) return;
    try {
      document.getElementById('statState').textContent = state.lkRoom.state || '—';

      // Get stats from local participant's audio tracks
      if (state.role === 'dj' && state.currentPub && state.currentPub.track) {
        try {
          const sender = state.currentPub.track.sender;
          if (sender && typeof sender.getStats === 'function') {
            const stats = await sender.getStats();
            stats.forEach(report => {
              if (report.type === 'outbound-rtp' && report.kind === 'audio') {
                if (report.bytesSent && report.timestamp) {
                  const kbps = Math.round((report.bytesSent * 8) / 1000);
                  document.getElementById('statBitrate').textContent = `${kbps} kbps`;
                }
                if (report.codecId) {
                  const codec = stats.get(report.codecId);
                  if (codec && codec.mimeType) {
                    document.getElementById('statCodec').textContent = codec.mimeType.split('/')[1] || codec.mimeType;
                  }
                }
                document.getElementById('statLoss').textContent = report.packetsLost !== undefined ? `${report.packetsLost}` : '0';
              }
              if (report.type === 'remote-inbound-rtp' && report.kind === 'audio') {
                if (report.roundTripTime !== undefined) {
                  document.getElementById('statLatency').textContent = `${Math.round(report.roundTripTime * 1000)} ms`;
                }
              }
            });
          }
        } catch (e) { log('DJ stats error:', e?.message || e); }
      } else if (state.role === 'listener') {
        // Listener: get stats from subscribed tracks
        const audioTracks = Array.from(state.lkRoom.remoteParticipants.values())
          .flatMap(p => Array.from(p.trackPublications.values()))
          .filter(pub => pub.kind === 'audio' && pub.track);

        if (audioTracks.length > 0) {
          const audioTrack = audioTracks[0].track;
          try {
            const receiver = audioTrack.receiver;
            if (receiver && typeof receiver.getStats === 'function') {
              const stats = await receiver.getStats();
              stats.forEach(report => {
                if (report.type === 'inbound-rtp' && report.kind === 'audio') {
                  if (report.bytesReceived && report.timestamp) {
                    const kbps = Math.round((report.bytesReceived * 8) / 1000);
                    document.getElementById('statBitrate').textContent = `${kbps} kbps`;
                  }
                  if (report.codecId) {
                    const codec = stats.get(report.codecId);
                    if (codec && codec.mimeType) {
                      document.getElementById('statCodec').textContent = codec.mimeType.split('/')[1] || codec.mimeType;
                    }
                  }
                  document.getElementById('statLoss').textContent = report.packetsLost !== undefined ? `${report.packetsLost}` : '0';
                  if (report.jitter !== undefined) {
                    document.getElementById('statLatency').textContent = `${Math.round(report.jitter * 1000)} ms`;
                  }
                }
              });
            }
          } catch (e) { log('Listener stats error:', e?.message || e); }
        }
      }
    } catch (e) { log('stats error', e?.message||e); }
  }, 2000);
}

function stopStatsMonitor() { if (state.statsInterval) clearInterval(state.statsInterval); state.statsInterval = null; }

setInterval(()=> {
  if (!state.clientId || !state.roomId) return;
  fetch('/presence/beat', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ client_id: state.clientId, room_id: state.roomId, role: state.role }) });
}, 15000);

async function ensureDeviceList() {
  try {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const audIns = devices.filter(d => d.kind === 'audioinput');
    const dropdown = document.getElementById('extDropdown');
    dropdown.innerHTML = '';
    audIns.forEach(d => {
      const item = document.createElement('div');
      item.className = 'dropdown-item';
      item.textContent = d.label || `audio ${d.deviceId.slice(0,6)}…`;
      item.onclick = async () => {
        state.extDeviceId = d.deviceId;
        dropdown.classList.remove('show');
        if (state.role === 'dj' && state.lkRoom) { const track = await createExternalTrack(state.extDeviceId); await publish(track); highlightActiveSource(); }
      };
      dropdown.appendChild(item);
    });
    if (!state.extDeviceId && audIns[0]) state.extDeviceId = audIns[0].deviceId;
  } catch (e) { log('device list error', e?.name || e?.message || e); }
}

async function enterRoom(roomId, role) {
  if (!(await roomExists(roomId))) { log('Room not found, redirecting to home'); navigateToRoot(); show(landing); await listRooms(); return; }
  state.roomId = roomId; state.role = role;
  const joinRes = await fetch(`/room/${roomId}/join`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ client_id: state.clientId, role }) });
  const ok = await joinRes.json();
  if (!ok.ok) { log('Join failed', ok.error||''); navigateToRoot(); show(landing); await listRooms(); return; }
  state.roomName = ok.name || state.roomName || '';
  const { url, token } = await fetchLkToken(role, roomId);
  await connectRoom(url, token);
  if (role === 'dj') {
    setDjRoomMeta();
    show(djView);
    await ensureDeviceList();
    await ensurePublishedPresence();
    updateMuteButton();
    highlightActiveSource();
  } else {
    const rooms = await (await fetch('/rooms')).json();
    const r = rooms.rooms.find(x=>x.id===roomId) || {};
    setListenerRoomMeta({ name: r.name, dj_name: r.dj_name, listener_count: r.listener_count });
    if (!r.dj_online) offline.classList.remove('hidden');
    show(listenerView);
  }
}

async function closeFloor() {
  if (!state.roomId || state.role !== 'dj') return;
  try {
    if (state.lkRoom) {
      const msg = new TextEncoder().encode(JSON.stringify({ type: 'room_close' }));
      try { await state.lkRoom.localParticipant.publishData(msg, { reliable: true }); } catch {}
    }
  } catch {}
  try { await fetch(`/room/${state.roomId}/close`, { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ client_id: state.clientId }) }); } catch {}
  try { state.lkRoom?.disconnect(); } catch {}
  state.lkRoom = null; state.localTrack = null; state.currentPub = null; state.onAir = false;
  stopStatsMonitor();
  navigateToRoot();
  show(landing);
  await listRooms();
}

document.getElementById('btnCreate').onclick = async ()=> {
  await ensureIdentityReady();
  const name = (document.getElementById('roomNameInput').value || '').trim() || `Room ${state.name}`;
  const res = await fetch('/room/create', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ client_id: state.clientId, name }) });
  const data = await res.json();
  if (!data.ok) { log('create failed', data.error||''); return; }
  const rid = data.room_id; state.roomName = name;
  navigateToRoom(rid, true);
  await enterRoom(rid, 'dj');
};

document.getElementById('srcMic').onclick = async ()=> {
  state.source = 'mic';
  if (state.role === 'dj' && state.lkRoom) { const track = await createMicTrack(); await publish(track); highlightActiveSource(); }
};

document.getElementById('srcTrack').onclick = ()=> {
  state.source = 'file';
  document.getElementById('fileInput').click();
  highlightActiveSource();
};

document.getElementById('srcExternal').onclick = async (e)=> {
  e.stopPropagation();
  state.source = 'external';
  try { await navigator.mediaDevices.getUserMedia({ audio:true, video:false }); } catch {}
  await ensureDeviceList();
  const dropdown = document.getElementById('extDropdown');
  dropdown.classList.toggle('show');
  highlightActiveSource();
};

document.addEventListener('click', (e) => {
  if (!e.target.closest('.dropdown')) document.getElementById('extDropdown').classList.remove('show');
});

document.getElementById('fileInput').onchange = async (e)=> {
  state.file = e.target.files?.[0] || null;
  if (state.role === 'dj' && state.lkRoom && state.file) { const { track } = await createFileTrack(state.file); await publish(track); highlightActiveSource(); }
};

btnMute.onclick = async ()=> {
  if (state.role !== 'dj' || !state.lkRoom) return;
  const targetOnAir = !state.onAir;
  if (!isAudioPublished() || !state.currentPub) {
    let track = state.localTrack;
    if (!track) {
      if (state.source === 'mic') track = await createMicTrack();
      else if (state.source === 'external') track = await createExternalTrack(state.extDeviceId);
      else if (state.source === 'file') { if (!state.file) { log('select a file first'); return; } ({ track } = await createFileTrack(state.file)); }
    }
    if (track) await publish(track);
  }
  if (state.currentPub && state.currentPub.track) {
    try { if (targetOnAir) await state.currentPub.track.unmute(); else await state.currentPub.track.mute(); } catch (e) { log('mute toggle error', e?.message||e); }
  }
  state.onAir = targetOnAir;
  updateMuteButton();
  refreshDjWave();
};

document.getElementById('btnClose').onclick = closeFloor;

window.addEventListener('popstate', async ()=> {
  const route = parseRoute();
  if (route.roomId) { await ensureIdentityReady(); await enterRoom(route.roomId, route.asDj ? 'dj' : 'listener'); }
  else { stopStatsMonitor(); show(landing); await listRooms(); }
});

window.addEventListener('load', async ()=>{
  await ensureIdentityReady();
  const route = parseRoute();
  if (route.roomId) {
    if (!(await roomExists(route.roomId))) { navigateToRoot(); show(landing); await listRooms(); return; }
    await enterRoom(route.roomId, route.asDj ? 'dj' : 'listener');
  } else {
    show(landing);
    await listRooms();
    setInterval(listRooms, 4000);
  }
  updateMuteButton();
});
</script>
</body>
</html>
