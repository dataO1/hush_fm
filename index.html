<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Silent Disco - P2P</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif; margin:0; padding:20px; background:#f5f7fb; color:#222; }
    .container { max-width: 960px; margin: 0 auto; }
    .card { background:#fff; border-radius:16px; box-shadow:0 8px 24px rgba(0,0,0,.08); padding:24px; margin:16px 0; }
    .btn { border:none; padding:10px 16px; border-radius:8px; background:#6366f1; color:#fff; cursor:pointer; margin-right:8px; }
    .btn.secondary { background:#0ea5e9; }
    .btn.danger { background:#ef4444; }
    audio { width:100%; margin-top:8px; }
    .muted { color:#888; font-size:.9rem; }
    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; background:#0b1220; color:#d1ffea; border-radius:12px; padding:12px; height:220px; overflow:auto; }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h2>Silent Disco (P2P)</h2>
      <div id="whoami" class="muted">Not identified</div>
    </div>

    <div id="controls" class="card">
      <input id="roomName" placeholder="Room name" style="width:100%; padding:10px; border-radius:8px; border:1px solid #ddd;"/>
      <div style="margin-top:10px;">
        <button class="btn" id="createBtn">Create room</button>
      </div>
      <div id="rooms" style="margin-top:12px;"></div>
    </div>

    <div id="djCard" class="card" style="display:none;">
      <h3>DJ Controls <span id="djRoom" class="muted"></span></h3>
      <input type="file" id="audioFile" accept="audio/*"/>
      <audio id="djAudio" controls></audio>
      <div style="margin-top:8px;">
        <button class="btn" id="djPlay">Play (local)</button>
        <button class="btn secondary" id="djPause">Pause (local)</button>
        <button class="btn danger" id="djStop">Stop (local)</button>
      </div>
      <div style="margin-top:12px;">
        <strong>Connected listeners</strong>
        <div id="peers" class="muted">None</div>
      </div>
    </div>

    <div id="listenerCard" class="card" style="display:none;">
      <h3>Listener <span id="liRoom" class="muted"></span></h3>
      <audio id="listenerAudio" autoplay controls></audio>
    </div>

    <div class="card">
      <h3>Log</h3>
      <div id="log" class="log"></div>
    </div>
  </div>

  <script>
    const API = location.origin;
    const WS_URL = `ws://${location.host}/ws`;

    // Dynamic ICE config (STUN + optional TURN from server)
    let ICE_CONFIG = { iceServers: [] };

    const state = {
      userId: null, username: null,
      roomId: null, role: null, clientId: null,
      ws: null, pcs: new Map(), pending: new Map(),
      listeners: new Set(), audioStream: null, senders: new Map()
    };

    state.pending ??= new Map();

    // Add near top of index.html
    const t0 = performance.now();
    const ts = () => (performance.now() - t0).toFixed(1);
    const log = (...a) => {
      console.log(`[${ts()}ms]`, ...a)

      const el = document.getElementById('log');
      if (el) {
        el.insertAdjacentHTML('beforeend', `<div>[${new Date().toLocaleTimeString()}] ${a}</div>`);
        el.scrollTop = el.scrollHeight;
      }

    };

    // Wrap your signaling send()
    function send(msg) {
      const json = JSON.stringify(msg);
      log('WS →', msg.type, 'bytes=', json.length, 'target=', msg.target, 'from=', msg.from);
      ws.send(json);
    }

    // Parse ICE for logging
    function describeCandidate(c) {
      const s = (c.candidate || '').trim();
      const type = (s.match(/ typ ([a-z]+)/) || [])[1] || 'unknown';
      const proto = (s.match(/ udp| tcp/) || [])[0]?.trim() || 'unknown';
      const addr = (s.match(/candidate:.* ([0-9a-zA-Z\.\-:]+) \d+ typ/) || [])[1] || 'addr?';
      const isMdns = /\.local(?:domain)?$/.test(addr);
      const isLoop = addr === '127.0.0.1' || addr === '::1';
      return { type, proto, addr, isMdns, isLoop };
    }

    function cid() { return 'client_' + Math.random().toString(36).slice(2, 11); }

    async function api(path, body) {
      const res = await fetch(API + path, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(body || {})
      });
      return res.json();
    }

    async function loadIceConfig() {
      try {
        const res = await fetch(API + '/config');
        const data = await res.json();
        if (data && Array.isArray(data.iceServers)) {
          ICE_CONFIG = { iceServers: data.iceServers };
          log(`Loaded ICE servers (${data.iceServers.length})`);
        } else {
          throw new Error('Invalid ICE config');
        }
      } catch (e) {
        // Fallback to STUN-only if server config fails
        ICE_CONFIG = { iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
        ]};
        log(`Using default STUN-only ICE (config error: ${e.message})`);
      }
    }

    async function identify() {
      const existing = localStorage.getItem('userId');
      const data = await api('/user/identify', { user_id: existing });
      if (data.success) {
        state.userId = data.user.user_id;
        state.username = data.user.username;
        localStorage.setItem('userId', state.userId);
        const who = document.getElementById('whoami');
        if (who) who.textContent = `Welcome ${state.username} (${state.userId.slice(0, 8)})`;
        log(`User identified: ${state.username}`);
        await listRooms();
      }
    }

    async function listRooms() {
      const res = await fetch(API + '/rooms');
      const data = await res.json();
      const el = document.getElementById('rooms');
      if (!el) return;
      el.innerHTML = '';
      if (!data.success || data.rooms.length === 0) {
        el.innerHTML = '<div class="muted">No rooms yet</div>';
        return;
      }
      data.rooms.forEach(r => {
        const live = r.is_live ? 'LIVE' : 'Offline';
        const div = document.createElement('div');
        div.className = 'card';
        div.innerHTML = `
          <div><strong>${r.name}</strong> (${live})</div>
          <div class="muted">DJ: ${r.dj_username} • listeners: ${r.listener_count}</div>
          <div style="margin-top:8px;"><button class="btn" data-room="${r.room_id}">Join as listener</button></div>`;
        div.querySelector('button').onclick = () => join(r.room_id, 'listener');
        el.appendChild(div);
      });
    }

    async function createRoom() {
      const name = document.getElementById('roomName').value || 'My Disco';
      const data = await api('/room/create', { user_id: state.userId, room_name: name });
      if (data.success) await join(data.room.room_id, 'dj');
    }

    async function join(roomId, role) {
      state.clientId = cid();
      state.role = role;
      state.roomId = roomId;
      const data = await api(`/room/${roomId}/join`, { user_id: state.userId, role, client_id: state.clientId });
      if (!data.success) return;

      if (role === 'dj') {
        document.getElementById('djCard').style.display = '';
        document.getElementById('listenerCard').style.display = 'none';
        document.getElementById('djRoom').textContent = roomId;
        setupDJ();
      } else {
        document.getElementById('listenerCard').style.display = '';
        document.getElementById('djCard').style.display = 'none';
        document.getElementById('liRoom').textContent = roomId;
      }
      connectWS();
      log(`✅ Joined room as ${role}`);
    }

    async function leave() {
      if (state.roomId && state.clientId) await api(`/room/${state.roomId}/leave`, { client_id: state.clientId });
      for (const [, pc] of state.pcs) pc.close();
      state.pcs.clear();
      state.senders?.clear();
      if (state.ws) { state.ws.close(); state.ws = null; }
      if (state.audioStream) { state.audioStream.getTracks().forEach(t => t.stop()); state.audioStream = null; }
      document.getElementById('djCard').style.display = 'none';
      document.getElementById('listenerCard').style.display = 'none';
      await listRooms();
      log('🚪 Left room');
    }

    function connectWS() {
      state.ws = new WebSocket(WS_URL);
      state.ws.onopen = () => {
        log('🔌 WebSocket connected');
        send({ type: 'register', client_id: state.clientId, room_id: state.roomId });
      };
      state.ws.onmessage = async (ev) => { const msg = JSON.parse(ev.data); await onSignal(msg); };
      state.ws.onerror = (e) => log(`WS error: ${e.message || e}`);
      state.ws.onclose = () => log('🔌 WebSocket disconnected');
    }

    function send(m) { if (state.ws && state.ws.readyState === 1) state.ws.send(JSON.stringify(m)); }

    async function onSignal(data) {
      const { type } = data;
      if (type === 'room_state' && state.role === 'dj') {
        for (const lid of data.clients) {
          if (lid === state.clientId) continue;
          if (!state.pcs.has(lid)) await createPCForListener(lid);
        }
      } else if (type === 'new_listener' && state.role === 'dj') {
        state.listeners.add(data.client_id);
        await createPCForListener(data.client_id);
      } else if (type === 'offer' && state.role === 'listener') {
        await onOffer(data);
      } else if (type === 'answer' && state.role === 'dj') {
        await onAnswer(data);
      } else if (type === 'ice-candidate') {
        await onIce(data);
      } else if (type === 'room_closed') {
        log('Room closed'); await leave();
      } else if (type === 'listener_left') {
        const pc = state.pcs.get(data.client_id);
        if (pc) pc.close();
        state.pcs.delete(data.client_id);
        state.listeners.delete(data.client_id);
        renderPeers();
      }
      renderPeers();
    }

    function renderPeers() {
      const el = document.getElementById('peers');
      if (!el) return;
      if (!state.listeners.size) { el.textContent = 'None'; return; }
      el.innerHTML = '';
      for (const lid of state.listeners) {
        const pc = state.pcs.get(lid);
        const st = pc ? pc.connectionState : 'init';
        const div = document.createElement('div');
        div.textContent = `${lid.slice(0,12)} — ${st}`;
        el.appendChild(div);
      }
    }

    async function ensureAudioBeforeOffer(pc) {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const dst = ctx.createMediaStreamDestination();
      const osc = ctx.createOscillator(); osc.frequency.value = 0; osc.connect(dst); osc.start();
      const track = dst.stream.getAudioTracks()[0];
      pc.addTransceiver('audio', { direction: 'sendonly' }).sender.replaceTrack(track);
      log('attached dummy silent track before offer');
    }


    function attachRecovery(pc, peerId, recreateFn) {
      let recovering = false;
      pc.onconnectionstatechange = async () => {
        log('conn=', pc.connectionState, 'peer=', peerId);
        if (pc.connectionState === 'failed' && !recovering) {
          recovering = true;
          try {
            const off = await pc.createOffer({ iceRestart: true });
            await pc.setLocalDescription(off);
            send({ type:'offer', sdp:off.sdp, sdpType:off.type, target:peerId, from:state.clientId });
            log('ICE restart sent', peerId);
          } catch (e) { log('restart error', e); }
          setTimeout(async () => {
            if (pc.connectionState !== 'connected') {
              try { pc.close(); } catch {}
              state.pcs.delete(peerId);
              log('recreate PC', peerId);
              await recreateFn(peerId);
            }
            recovering = false;
          }, 3000);
        }
      };
    }

    // DJ: create PC for listener; use transceiver-first approach and later replaceTrack
    // DJ: create a PC for a specific listener and send ICE to that listenerId
    async function createPCForListener(listenerId) {
      const pc = new RTCPeerConnection(ICE_CONFIG);
      await ensureAudioBeforeOffer(pc);
      const tx = pc.addTransceiver('audio', { direction:'sendonly' });
      const track = state.audioStream.getAudioTracks()[0];
      await tx.sender.replaceTrack(track);
      state.pcs.set(listenerId, pc);

      log('PC[dj]', listenerId, 'created, cfg iceServers=', ICE_CONFIG.iceServers?.length);

      pc.onicegatheringstatechange = () => log('gathering=', pc.iceGatheringState);
      pc.oniceconnectionstatechange = () => log('ice=', pc.iceConnectionState);
      pc.onconnectionstatechange = () => log('conn=', pc.connectionState);
      pc.onsignalingstatechange = () => log('signal=', pc.signalingState);

      pc.onicecandidate = (e) => {
        if (!e.candidate) { log('ICE gather complete'); return; }
        const s = e.candidate.candidate || '';
        const type = (s.match(/ typ ([a-z]+)/)||[])[1] || 'unknown';
        const proto = (s.match(/ udp| tcp/)||[])[0]?.trim() || 'unknown';
        const addr = (s.match(/candidate:.* ([0-9a-zA-Z\.\-:]+) \d+ typ/)||[])[1] || 'addr?';
        const isMdns = /\.local(?:domain)?$/.test(addr);
        const isLoop = addr === '127.0.0.1' || addr === '::1';
        log('send ICE', {type, proto, addr, isMdns, isLoop});
        send({ type:'ice-candidate', candidate:e.candidate, target:listenerId, from:state.clientId });
      };
      // Poll stats to confirm nomination

      const statsTimer = setInterval(async () => {
        try {
          if (['failed','closed'].includes(pc.connectionState)) { clearInterval(statsTimer); return; }
          const stats = await pc.getStats();
          // inspect candidate-pair for nomination
          stats.forEach(r => {
            if (r.type === 'candidate-pair' && r.nominated && r.state === 'succeeded') {
              log('selected pair', {local:r.localCandidateId, remote:r.remoteCandidateId, proto:r.protocol});
            }
          });
        } catch { clearInterval(statsTimer); }
      }, 500);
      attachRecovery(pc, listenerId, createPCForListener);
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      log('PC[dj]', listenerId, 'setLocalDescription offer len=', offer.sdp.length);
      send({ type: 'offer', sdp: offer.sdp, sdpType: offer.type, target: listenerId, from: state.clientId });
    }

    // Listener: handle offer → answer
    // Listener: capture djId from the offer and send ICE back to that djId
    async function onOffer({ from, sdp, sdpType }) {
      const djId = from;
      let pc = state.pcs.get(djId);
      if (!pc) {
        pc = new RTCPeerConnection(ICE_CONFIG);
        state.pcs.set(djId, pc);
        state.pending ??= new Map();
        log('PC[listener]', djId, 'created');

        pc.onicegatheringstatechange = () => log('gathering=', pc.iceGatheringState);
        pc.oniceconnectionstatechange = () => log('ice=', pc.iceConnectionState);
        pc.onconnectionstatechange = () => log('conn=', pc.connectionState);
        pc.onsignalingstatechange = () => log('signal=', pc.signalingState);

        pc.onicecandidate = (e) => {
          if (!e.candidate) { log('ICE gather complete'); return; }
          const s = e.candidate.candidate || '';
          const type = (s.match(/ typ ([a-z]+)/)||[])[1] || 'unknown';
          const proto = (s.match(/ udp| tcp/)||[])[0]?.trim() || 'unknown';
          const addr = (s.match(/candidate:.* ([0-9a-zA-Z\.\-:]+) \d+ typ/)||[])[1] || 'addr?';
          const isMdns = /\.local(?:domain)?$/.test(addr);
          const isLoop = addr === '127.0.0.1' || addr === '::1';
          log('send ICE', {type, proto, addr, isMdns, isLoop});
          send({ type:'ice-candidate', candidate:e.candidate, target:djId, from:state.clientId });
        };

        // Poll stats to confirm nomination
        const statsTimer = setInterval(async () => {
          try {
            if (['failed','closed'].includes(pc.connectionState)) { clearInterval(statsTimer); return; }
            const stats = await pc.getStats();
            // inspect candidate-pair for nomination
            stats.forEach(r => {
              if (r.type === 'candidate-pair' && r.nominated && r.state === 'succeeded') {
                log('selected pair', {local:r.localCandidateId, remote:r.remoteCandidateId, proto:r.protocol});
              }
            });
          } catch { clearInterval(statsTimer); }
        }, 500);
        pc.ontrack = (ev) => {
          log('PC[listener]', djId, 'ontrack streams=', ev.streams?.length || 0);
          const el = document.getElementById('listenerAudio');
          el.srcObject = ev.streams[0];
          el.play().then(()=>log('PC[listener]', djId, 'audio playing')).catch(e=>log('PC[listener]', djId, 'play error', e));
        };

        const recreateForDj = async (peerId) => {
        // here you might send a control message to request a new offer,
        // or just rely on the DJ’s recovery to re-offer automatically
          log('listener awaiting new offer from', peerId);
        };
        attachRecovery(pc, djId, recreateForDj);
      }

      await pc.setRemoteDescription({ type: sdpType, sdp });
      log('PC[listener]', djId, 'setRemoteDescription offer len=', sdp.length);

      const pend = state.pending.get(djId) || [];
      if (pend.length) { log('PC[listener]', djId, 'draining pending ICE count=', pend.length); }
      for (const c of pend) await pc.addIceCandidate(new RTCIceCandidate(c));
      state.pending.delete(djId);

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      send({ type: 'answer', sdp: answer.sdp, sdpType: answer.type, target: djId, from: state.clientId });
    }

    async function onAnswer({ from, sdp, sdpType }) {
      const pc = state.pcs.get(from);
      if (!pc) return log('PC[dj]', from, 'answer for missing pc');
      await pc.setRemoteDescription({ type: sdpType, sdp });
      log('PC[dj]', from, 'setRemoteDescription answer len=', sdp.length);

      const pend = state.pending?.get(from);
      if (pend?.length) {
        log('PC[dj]', from, 'draining pending ICE count=', pend.length);
        for (const c of pend) await pc.addIceCandidate(new RTCIceCandidate(c));
        state.pending.delete(from);
      }
    }

    async function onIce({ from, candidate }) {
      const pc = state.pcs.get(from);
      if (!pc || !pc.remoteDescription) {
        const list = state.pending.get(from) || [];
        list.push(candidate);
        state.pending.set(from, list);
        log('PC[listener]', from, 'queued ICE (no remoteDesc) count=', list.length);
        return;
      }
      const d = describeCandidate(candidate);
      await pc.addIceCandidate(new RTCIceCandidate(candidate));
      log('PC[listener]', from, 'added ICE', d);
    }
    // DJ setup — real stream created on file select; replaceTrack on all senders
    function setupDJ() {
      const file = document.getElementById('audioFile');
      const djAudio = document.getElementById('djAudio');

      file.onchange = async (e) => {
        const f = e.target.files[0];
        if (!f) return;
        djAudio.src = URL.createObjectURL(f);

        const ctx = new AudioContext();
        const src = ctx.createMediaElementSource(djAudio);
        const dst = ctx.createMediaStreamDestination();
        src.connect(dst);
        src.connect(ctx.destination);
        state.audioStream = dst.stream;
        log('✅ Audio stream ready');

        const track = state.audioStream.getAudioTracks()[0];
        if (track) {
          for (const [lid, sender] of state.senders) {
            try {
              await sender.replaceTrack(track);
              log(`Attached real track to ${lid}`);
            } catch (err) {
              log(`replaceTrack error (${lid}): ${err.message}`);
            }
          }
        }
      };

      document.getElementById('djPlay').onclick = () => { djAudio.play(); log('▶️ Playing (local)'); };
      document.getElementById('djPause').onclick = () => { djAudio.pause(); log('⏸️ Paused (local)'); };
      document.getElementById('djStop').onclick = () => { djAudio.pause(); djAudio.currentTime = 0; log('⏹️ Stopped (local)'); };
    }

    // Boot: first load ICE config, then identify
    document.getElementById('createBtn').onclick = createRoom;
    window.addEventListener('load', async () => {
      await loadIceConfig();
      await identify();
      setInterval(() => { if (!state.roomId) listRooms(); }, 5000);
    });
  </script>
</body>
</html>
