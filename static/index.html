<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Silent Disco - P2P</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif; margin:0; padding:20px; background:#f5f7fb; color:#222; }
    .container { max-width: 960px; margin: 0 auto; }
    .card { background:#fff; border-radius:16px; box-shadow:0 8px 24px rgba(0,0,0,.08); padding:24px; margin:16px 0; }
    .btn { border:none; padding:10px 16px; border-radius:8px; background:#6366f1; color:#fff; cursor:pointer; margin-right:8px; }
    .btn.secondary { background:#0ea5e9; }
    .btn.danger { background:#ef4444; }
    audio { width:100%; margin-top:8px; }
    .muted { color:#888; font-size:.9rem; }
    .log { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; background:#0b1220; color:#d1ffea; border-radius:12px; padding:12px; height:220px; overflow:auto; }
  </style>
</head>
<body>
  <div class="container">
    <div class="card">
      <h2>Silent Disco (P2P)</h2>
      <div id="whoami" class="muted">Not identified</div>
    </div>

    <div id="controls" class="card">
      <input id="roomName" placeholder="Room name" style="width:100%; padding:10px; border-radius:8px; border:1px solid #ddd;"/>
      <div style="margin-top:10px;">
        <button class="btn" id="createBtn">Create room</button>
      </div>
      <div id="rooms" style="margin-top:12px;"></div>
    </div>

    <div id="djCard" class="card" style="display:none;">
      <h3>DJ Controls <span id="djRoom" class="muted"></span></h3>
      <input type="file" id="audioFile" accept="audio/*"/>
      <audio id="djAudio" controls></audio>
      <div style="margin-top:8px;">
        <button class="btn" id="djPlay">Play (local)</button>
        <button class="btn secondary" id="djPause">Pause (local)</button>
        <button class="btn danger" id="djStop">Stop (local)</button>
      </div>
      <div style="margin-top:12px;">
        <strong>Connected listeners</strong>
        <div id="peers" class="muted">None</div>
      </div>
    </div>

    <div id="listenerCard" class="card" style="display:none;">
      <h3>Listener <span id="liRoom" class="muted"></span></h3>
      <audio id="listenerAudio" autoplay controls></audio>
      <div class="muted" style="margin-top:6px;">Live WebRTC stream plays continuously; no buffering or remote pause.</div>
    </div>

    <div class="card">
      <h3>Log</h3>
      <div id="log" class="log"></div>
    </div>
  </div>

  <script>
    const API = location.origin;
    const WS_URL = `ws://${location.host}/ws`;

    // Dynamic ICE config (STUN + optional TURN from server)
    let ICE_CONFIG = { iceServers: [] };

    const state = {
      userId: null, username: null,
      roomId: null, role: null, clientId: null,
      ws: null, pcs: new Map(), pending: new Map(),
      listeners: new Set(), audioStream: null, senders: new Map()
    };

    function log(msg) {
      console.log(msg);
      const el = document.getElementById('log');
      if (el) {
        el.insertAdjacentHTML('beforeend', `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`);
        el.scrollTop = el.scrollHeight;
      }
    }

    function cid() { return 'client_' + Math.random().toString(36).slice(2, 11); }

    async function api(path, body) {
      const res = await fetch(API + path, {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(body || {})
      });
      return res.json();
    }

    async function loadIceConfig() {
      try {
        const res = await fetch(API + '/config');
        const data = await res.json();
        if (data && Array.isArray(data.iceServers)) {
          ICE_CONFIG = { iceServers: data.iceServers };
          log(`Loaded ICE servers (${data.iceServers.length})`);
        } else {
          throw new Error('Invalid ICE config');
        }
      } catch (e) {
        // Fallback to STUN-only if server config fails
        ICE_CONFIG = { iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
        ]};
        log(`Using default STUN-only ICE (config error: ${e.message})`);
      }
    }

    async function identify() {
      const existing = localStorage.getItem('userId');
      const data = await api('/user/identify', { user_id: existing });
      if (data.success) {
        state.userId = data.user.user_id;
        state.username = data.user.username;
        localStorage.setItem('userId', state.userId);
        const who = document.getElementById('whoami');
        if (who) who.textContent = `Welcome ${state.username} (${state.userId.slice(0, 8)})`;
        log(`User identified: ${state.username}`);
        await listRooms();
      }
    }

    async function listRooms() {
      const res = await fetch(API + '/rooms');
      const data = await res.json();
      const el = document.getElementById('rooms');
      if (!el) return;
      el.innerHTML = '';
      if (!data.success || data.rooms.length === 0) {
        el.innerHTML = '<div class="muted">No rooms yet</div>';
        return;
      }
      data.rooms.forEach(r => {
        const live = r.is_live ? 'LIVE' : 'Offline';
        const div = document.createElement('div');
        div.className = 'card';
        div.innerHTML = `
          <div><strong>${r.name}</strong> (${live})</div>
          <div class="muted">DJ: ${r.dj_username} • listeners: ${r.listener_count}</div>
          <div style="margin-top:8px;"><button class="btn" data-room="${r.room_id}">Join as listener</button></div>`;
        div.querySelector('button').onclick = () => join(r.room_id, 'listener');
        el.appendChild(div);
      });
    }

    async function createRoom() {
      const name = document.getElementById('roomName').value || 'My Disco';
      const data = await api('/room/create', { user_id: state.userId, room_name: name });
      if (data.success) await join(data.room.room_id, 'dj');
    }

    async function join(roomId, role) {
      state.clientId = cid();
      state.role = role;
      state.roomId = roomId;
      const data = await api(`/room/${roomId}/join`, { user_id: state.userId, role, client_id: state.clientId });
      if (!data.success) return;

      if (role === 'dj') {
        document.getElementById('djCard').style.display = '';
        document.getElementById('listenerCard').style.display = 'none';
        document.getElementById('djRoom').textContent = roomId;
        setupDJ();
      } else {
        document.getElementById('listenerCard').style.display = '';
        document.getElementById('djCard').style.display = 'none';
        document.getElementById('liRoom').textContent = roomId;
      }
      connectWS();
      log(`✅ Joined room as ${role}`);
    }

    async function leave() {
      if (state.roomId && state.clientId) await api(`/room/${state.roomId}/leave`, { client_id: state.clientId });
      for (const [, pc] of state.pcs) pc.close();
      state.pcs.clear();
      state.senders?.clear();
      if (state.ws) { state.ws.close(); state.ws = null; }
      if (state.audioStream) { state.audioStream.getTracks().forEach(t => t.stop()); state.audioStream = null; }
      document.getElementById('djCard').style.display = 'none';
      document.getElementById('listenerCard').style.display = 'none';
      await listRooms();
      log('🚪 Left room');
    }

    function connectWS() {
      state.ws = new WebSocket(WS_URL);
      state.ws.onopen = () => {
        log('🔌 WebSocket connected');
        send({ type: 'register', client_id: state.clientId, room_id: state.roomId });
      };
      state.ws.onmessage = async (ev) => { const msg = JSON.parse(ev.data); await onSignal(msg); };
      state.ws.onerror = (e) => log(`WS error: ${e.message || e}`);
      state.ws.onclose = () => log('🔌 WebSocket disconnected');
    }

    function send(m) { if (state.ws && state.ws.readyState === 1) state.ws.send(JSON.stringify(m)); }

    async function onSignal(data) {
      const { type } = data;
      if (type === 'room_state' && state.role === 'dj') {
        for (const lid of data.clients) {
          if (lid === state.clientId) continue;
          if (!state.pcs.has(lid)) await createPCForListener(lid);
        }
      } else if (type === 'new_listener' && state.role === 'dj') {
        state.listeners.add(data.client_id);
        await createPCForListener(data.client_id);
      } else if (type === 'offer' && state.role === 'listener') {
        await onOffer(data);
      } else if (type === 'answer' && state.role === 'dj') {
        await onAnswer(data);
      } else if (type === 'ice-candidate') {
        await onIce(data);
      } else if (type === 'room_closed') {
        log('Room closed'); await leave();
      } else if (type === 'listener_left') {
        const pc = state.pcs.get(data.client_id);
        if (pc) pc.close();
        state.pcs.delete(data.client_id);
        state.listeners.delete(data.client_id);
        renderPeers();
      }
      renderPeers();
    }

    function renderPeers() {
      const el = document.getElementById('peers');
      if (!el) return;
      if (!state.listeners.size) { el.textContent = 'None'; return; }
      el.innerHTML = '';
      for (const lid of state.listeners) {
        const pc = state.pcs.get(lid);
        const st = pc ? pc.connectionState : 'init';
        const div = document.createElement('div');
        div.textContent = `${lid.slice(0,12)} — ${st}`;
        el.appendChild(div);
      }
    }

    // DJ: create PC for listener; use transceiver-first approach and later replaceTrack
    async function createPCForListener(listenerId) {
      log(`Creating PC to ${listenerId}`);
      const pc = new RTCPeerConnection(ICE_CONFIG);
      state.pcs.set(listenerId, pc);

      const transceiver = pc.addTransceiver('audio', { direction: 'sendonly' });
      const sender = transceiver.sender;
      state.senders.set?.(listenerId, sender);

      if (state.audioStream) {
        const track = state.audioStream.getAudioTracks()[0];
        if (track) {
          await sender.replaceTrack(track);
          log(`Attached real track to ${listenerId}`);
        }
      }

      pc.onicecandidate = (e) => {
        if (e.candidate) send({ type: 'ice-candidate', candidate: e.candidate, target: listenerId, from: state.clientId });
      };

      pc.onconnectionstatechange = async () => {
        log(`PC(${listenerId}) ${pc.connectionState}`);
        renderPeers();
        if (pc.connectionState === 'failed') {
          try {
            pc.onicecandidate = null;
            pc.onconnectionstatechange = null;
            pc.close();
            state.pcs.delete(listenerId);
            state.senders.delete(listenerId);
            log(`Rebuilding PC for ${listenerId} after failure...`);
            await new Promise(r => setTimeout(r, 250));
            await createPCForListener(listenerId);
          } catch (err) {
            log(`Retry failed for ${listenerId}: ${err.message}`);
          }
        }
      };

      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      send({ type: 'offer', sdp: offer.sdp, sdpType: offer.type, target: listenerId, from: state.clientId });
      log(`Offer sent to ${listenerId}`);
    }

    // Listener: handle offer → answer
    async function onOffer({ from, sdp, sdpType }) {
      log(`📥 Received offer from ${from}`);
      const pc = new RTCPeerConnection(ICE_CONFIG);
      state.pcs.set(from, pc);

      pc.ontrack = (ev) => {
        log('🎵 Received audio track from DJ');
        const el = document.getElementById('listenerAudio');
        el.srcObject = ev.streams[0];
        el.play().then(() => log('✅ Audio playing')).catch(err => log(`Autoplay error: ${err.message}`));
      };

      pc.onicecandidate = (e) => {
        if (e.candidate) send({ type: 'ice-candidate', candidate: e.candidate, target: from, from: state.clientId });
      };

      await pc.setRemoteDescription(new RTCSessionDescription({ type: sdpType, sdp }));

      const pend = state.pending.get(from);
      if (pend) {
        for (const c of pend) await pc.addIceCandidate(new RTCIceCandidate(c));
        state.pending.delete(from);
      }

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      send({ type: 'answer', sdp: answer.sdp, sdpType: answer.type, target: from, from: state.clientId });
      log('📤 Sent answer to DJ');
    }

    async function onAnswer({ from, sdp, sdpType }) {
      const pc = state.pcs.get(from);
      if (!pc) { log(`No PC for ${from}`); return; }
      await pc.setRemoteDescription(new RTCSessionDescription({ type: sdpType, sdp }));
      const pend = state.pending.get(from);
      if (pend) {
        for (const c of pend) await pc.addIceCandidate(new RTCIceCandidate(c));
        state.pending.delete(from);
      }
      log(`Answer set from ${from}`);
    }

    async function onIce({ from, candidate }) {
      const pc = state.pcs.get(from);
      if (!pc) {
        const list = state.pending.get(from) || [];
        list.push(candidate);
        state.pending.set(from, list);
        log(`⏳ Queued ICE from ${from}`);
        return;
      }
      if (pc.remoteDescription) {
        await pc.addIceCandidate(new RTCIceCandidate(candidate));
        log(`✅ Added ICE from ${from}`);
      } else {
        const list = state.pending.get(from) || [];
        list.push(candidate);
        state.pending.set(from, list);
        log(`⏳ Queued ICE (no remote desc) from ${from}`);
      }
    }

    // DJ setup — real stream created on file select; replaceTrack on all senders
    function setupDJ() {
      const file = document.getElementById('audioFile');
      const djAudio = document.getElementById('djAudio');

      file.onchange = async (e) => {
        const f = e.target.files[0];
        if (!f) return;
        djAudio.src = URL.createObjectURL(f);

        const ctx = new AudioContext();
        const src = ctx.createMediaElementSource(djAudio);
        const dst = ctx.createMediaStreamDestination();
        src.connect(dst);
        src.connect(ctx.destination);
        state.audioStream = dst.stream;
        log('✅ Audio stream ready');

        const track = state.audioStream.getAudioTracks()[0];
        if (track) {
          for (const [lid, sender] of state.senders) {
            try {
              await sender.replaceTrack(track);
              log(`Attached real track to ${lid}`);
            } catch (err) {
              log(`replaceTrack error (${lid}): ${err.message}`);
            }
          }
        }
      };

      document.getElementById('djPlay').onclick = () => { djAudio.play(); log('▶️ Playing (local)'); };
      document.getElementById('djPause').onclick = () => { djAudio.pause(); log('⏸️ Paused (local)'); };
      document.getElementById('djStop').onclick = () => { djAudio.pause(); djAudio.currentTime = 0; log('⏹️ Stopped (local)'); };
    }

    // Boot: first load ICE config, then identify
    document.getElementById('createBtn').onclick = createRoom;
    window.addEventListener('load', async () => {
      await loadIceConfig();
      await identify();
      setInterval(() => { if (!state.roomId) listRooms(); }, 5000);
    });
  </script>
</body>
</html>
